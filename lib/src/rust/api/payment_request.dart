// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `validate`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_str`, `from`, `from`, `from`, `from`, `from`, `from`, `into`, `into`, `into`, `try_into`, `try_into`

enum Nut10Kind {
  p2Pk,
  htlc,
  ;
}

class Nut10SecretRequest {
  final Nut10Kind kind;
  final SecretDataRequest secretData;

  const Nut10SecretRequest({
    required this.kind,
    required this.secretData,
  });

  static Nut10SecretRequest htlc({required String preimage}) =>
      RustLib.instance.api
          .crateApiPaymentRequestNut10SecretRequestHtlc(preimage: preimage);

  static Nut10SecretRequest p2Pk({required String publicKey}) =>
      RustLib.instance.api
          .crateApiPaymentRequestNut10SecretRequestP2Pk(publicKey: publicKey);

  @override
  int get hashCode => kind.hashCode ^ secretData.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Nut10SecretRequest &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          secretData == other.secretData;
}

class PaymentRequest {
  final String? paymentId;
  final BigInt? amount;
  final String? unit;
  final bool? singleUse;
  final List<String>? mints;
  final String? description;
  final List<Transport>? transports;
  final Nut10SecretRequest? nut10;

  const PaymentRequest({
    this.paymentId,
    this.amount,
    this.unit,
    this.singleUse,
    this.mints,
    this.description,
    this.transports,
    this.nut10,
  });

  String encode() =>
      RustLib.instance.api.crateApiPaymentRequestPaymentRequestEncode(
        that: this,
      );

  static PaymentRequest parse({required String encoded}) => RustLib.instance.api
      .crateApiPaymentRequestPaymentRequestParse(encoded: encoded);

  @override
  int get hashCode =>
      paymentId.hashCode ^
      amount.hashCode ^
      unit.hashCode ^
      singleUse.hashCode ^
      mints.hashCode ^
      description.hashCode ^
      transports.hashCode ^
      nut10.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentRequest &&
          runtimeType == other.runtimeType &&
          paymentId == other.paymentId &&
          amount == other.amount &&
          unit == other.unit &&
          singleUse == other.singleUse &&
          mints == other.mints &&
          description == other.description &&
          transports == other.transports &&
          nut10 == other.nut10;
}

class SecretDataRequest {
  final String data;
  final List<List<String>>? tags;

  const SecretDataRequest({
    required this.data,
    this.tags,
  });

  @override
  int get hashCode => data.hashCode ^ tags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecretDataRequest &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          tags == other.tags;
}

class Transport {
  final TransportType type;
  final String target;
  final List<List<String>>? tags;

  const Transport({
    required this.type,
    required this.target,
    this.tags,
  });

  @override
  int get hashCode => type.hashCode ^ target.hashCode ^ tags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Transport &&
          runtimeType == other.runtimeType &&
          type == other.type &&
          target == other.target &&
          tags == other.tags;
}

enum TransportType {
  nostr,
  httpPost,
  ;
}
